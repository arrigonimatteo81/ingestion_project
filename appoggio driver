source .venv/bin/activate
python3 main_orchestrator.py -r 20251228_115000 -g TEST_GROUP -c application.conf

Punto fermo

üëâ Il tuo codice √® gi√† un ‚ÄúTask‚Äù orchestratore.
Quello che manca √®:

separare meglio le responsabilit√†

rendere estendibili le parti ‚Äúalcuni task fanno anche X‚Äù

Non devi buttare via nulla.

Cosa rappresenta il TUO codice oggi

Questa classe sta facendo 3 cose insieme:

Orchestrazione del task

Logging di stato

Decisioni condizionali (blocking / non blocking)

Va bene, ma √® il punto giusto dove agganciare:

conteggio righe

post-azioni (update registro, ecc.)

Come adattarlo alle indicazioni (step by step)
1Ô∏è‚É£ _get_common_data() ‚Üí torna anche le PostTaskAction

Oggi:

task_source, task_is_blocking, task_destination = self._get_common_data()


üëâ Estendilo senza rompere nulla:

task_source, task_is_blocking, task_destination, post_actions = self._get_common_data()


Dentro _get_common_data():

leggi configurazione task

costruisci:

Source

Destination

lista di PostTaskAction (vuota per molti task)

2Ô∏è‚É£ Conteggio righe ‚Üí qui √® il punto giusto

Subito dopo il read:

df = task_source.to_dataframe(session)
row_count = df.count()


Questo valore:

lo logghi

lo passi alle post-azioni

lo puoi salvare nel DB

3Ô∏è‚É£ Inserisci le PostTaskAction (senza if)

Subito dopo la write:

task_destination.write(df)

for action in post_actions:
    action.execute(df, task_context)


‚ö†Ô∏è Nota: post_actions pu√≤ essere [], quindi zero impatto sugli altri task.

4Ô∏è‚É£ TaskContext: NON stravolgerti

Non serve riscrivere tutto.
Puoi iniziare minimal.

TaskContext minimale
class TaskContext:
    def __init__(self, task, run_id, repository):
        self.task = task
        self.run_id = run_id
        self.repository = repository
        self.row_count = None

5Ô∏è‚É£ Codice finale adattato (quasi identico al tuo)
try:
    self._repository.insert_task_log_running(
        self._task.uid, self._run_id,
        f"task {self._task.uid} avviato"
    )

    logger.debug(f"inizio {self._task.uid}, {self._run_id}")

    (
        task_source,
        task_is_blocking,
        task_destination,
        post_actions
    ) = self._get_common_data()

    session = self._get_spark_session()

    task_context = TaskContext(
        task=self._task,
        run_id=self._run_id,
        repository=self._repository
    )

    df = task_source.to_dataframe(session)

    task_context.row_count = df.count()

    task_destination.write(df)

    for action in post_actions:
        action.execute(df, task_context)

    self._repository.insert_task_log_successful(
        self._task.uid,
        self._run_id,
        f"task {self._task.uid} concluso con successo "
        f"(righe={task_context.row_count})"
    )

    logger.debug(f"task {self._task.uid} concluso con successo")

    return OperationResult(successful=True, description="")

except Exception as exc:
    ...

6Ô∏è‚É£ Esempio di PostTaskAction concreta (registro)
class UpdateRegistroAction(PostTaskAction):

    def execute(self, df, ctx: TaskContext):
        max_value = df.agg(F.max("data_rif")).collect()[0][0]

        ctx.repository.update_registro(
            ctx.task.uid,
            max_value
        )

Perch√© cos√¨ funziona (e scala)

‚úî Non tocchi la Source
‚úî Non tocchi la Destination
‚úî Nessun if task_type == ...
‚úî _get_common_data() diventa il punto di configurazione
‚úî Task rimane leggibile
‚úî Logging e stato restano dove sono

TL;DR operativo

Estendi _get_common_data() ‚Üí ritorna anche post_actions

Calcola df.count() nel task

Introduci TaskContext minimale

Esegui le post-azioni dopo la write

Nessuna logica nella Source

Se vuoi, nel prossimo messaggio posso:

aiutarti a rifattorizzare _get_common_data()

mostrarti come caricare le post-azioni da DB

dirti come evitare doppie action su retry

ottimizzare count() + max() in una sola passata

---------------------------------------------------
Domanda centrale.
La risposta onesta √®: s√¨, un if da qualche parte ci deve essere.
La risposta architetturalmente corretta √®: non l√¨, e non cos√¨.

Ti spiego dove s√¨, dove no, e perch√©.

Punto chiave

üëâ La scelta della PostAction dipende dalla configurazione del task,
non dalla logica del TaskRunner.

_get_common_data() non deve conoscere il significato delle tabelle.

‚ùå Quello che stai per fare (e perch√© √® un problema)
def _get_common_data():
    ...
    if nome_tabella == "T_FATTURE":
        post_actions = [UpdateRegistroAction()]


Problemi:

_get_common_data() diventa knowledge hub

accoppi TaskRunner ‚Üî nomi fisici tabelle

ogni nuova tabella = modifica codice

test difficili

‚úÖ Dove DEVE stare la decisione
Nel metadata del task (DB / config)

Il concetto giusto √®:

‚ÄúQuesto task ha una post-action X‚Äù

Non:

‚ÄúSe leggo la tabella Y allora‚Ä¶‚Äù

Soluzione corretta (pragmatica)
1Ô∏è‚É£ Metti l‚Äôinformazione nel DB (o YAML)

Esempio tabella TASK_CONFIG:

task_uid	source	destination	post_action
T01	SRC_A	T_FATTURE	UPDATE_REGISTRO
T02	SRC_B	FILE_X	NULL

Oppure:

{
  "post_actions": ["UPDATE_REGISTRO"]
}

2Ô∏è‚É£ Factory delle PostAction (unico punto con if)
class PostTaskActionFactory:

    def create(self, task_config) -> list[PostTaskAction]:
        actions = []

        for action_code in task_config.post_actions:
            if action_code == "UPDATE_REGISTRO":
                actions.append(UpdateRegistroAction())

        return actions


üëâ Qui l‚Äôif √® giusto, perch√©:

traduce config ‚Üí oggetti

√® il suo lavoro

3Ô∏è‚É£ _get_common_data() diventa neutra
def _get_common_data():
    task_config = self._repository.get_task_config(self._task.uid)

    source = SourceFactory.create(task_config)
    destination = SinkFactory.create(task_config)
    post_actions = PostTaskActionFactory().create(task_config)

    return source, task_config.is_blocking, destination, post_actions