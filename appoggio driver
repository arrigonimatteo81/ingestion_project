source .venv/bin/activate
python3 main_orchestrator.py -r 20251228_115000 -g TEST_GROUP -c application.conf
----------------------------------
------------query di upsert in registro-------------
INSERT INTO registro (
    chiave,
    last_id,
    max_data_va,
    updated_at
)
VALUES (
    :chiave,
    :last_id,
    :max_data_va,
    NOW()
)
ON CONFLICT (chiave)
DO UPDATE SET
    last_id = EXCLUDED.last_id,
    max_data_va = EXCLUDED.max_data_va,
    updated_at = NOW()
WHERE registro.last_id < EXCLUDED.last_id;
-------tabella che l'orchestrator deve leggere e confronta semaforo/registro con chiave json (diverse per tipo_caricamento)----------------------------
select
	s.*
from
	(
	select
		id,
		tabella,
		tipo_caricamento ,
		colonna_valore,
		ambito,
		case
			when tipo_caricamento = 'DOMINI' then
            	jsonb_build_object('tabella',tabella)
			else
            	jsonb_build_object('cod_abi',cod_abi,
								   'tabella',tabella,
								   'provenienza',provenienza
            )
		end as chiave
	from
		public.semaforo_mensile)s
left join public.tab_registro_mensile r
    on
	r.chiave = s.chiave
where
	r.last_id is null
	or s.id > r.last_id;
------class TaskSemaforo-------------
from dataclasses import dataclass
from typing import Dict

@dataclass(frozen=True)
class TaskSemaforo:
    uid: str
    id_semaforo: int
    source_id: str
    destination_id: str
    tipo_caricamento: str
    key: Dict
    query_params: Dict
-----class TaskSemaforoPayload(per il passaggio info tra orchestrator e processor)------
from dataclasses import dataclass, asdict
from typing import Dict, Optional
import json


@dataclass
class TaskSemaforoPayload:
    # identitÃ  tecnica
    uid: str
    id_semaforo: int

    # configurazione tecnica
    source_id: str
    destination_id: str
    tipo_caricamento: str

    # business
    key: Dict
    query_params: Dict

    def to_json(self) -> str:
        return json.dumps(asdict(self))

    @classmethod
    def from_json(cls, json_str: str) -> "TaskSemaforoPayload":
        return cls(**json.loads(json_str))

    def to_domain(self) -> "TaskSemaforo":
        return TaskSemaforo(
            uid=self.uid,
            id_semaforo=self.id_semaforo,
            source_id=self.source_id,
            destination_id=self.destination_id,
            tipo_caricamento=self.tipo_caricamento,
            key=self.key,
            query_params=self.query_params
        )

---nell'orchestrator leggo la semaforo_ready e costruisco la TaskSemaforoPayload(row dovrebbe essere la riga che leggo dalla "semaforo_ready")---
payload = TaskSemaforoPayload(
    uid=row["uid"],
    id_semaforo=row["id"],
    source_id=row["source_id"],
    destination_id=row["destination_id"],
    tipo_caricamento=row["tipo_caricamento"],
    key=row["chiave"],
    query_params={
        "num_periodo_rif": row["num_periodo_rif"]
    }
)
-------TaskContext-----------
@dataclass(frozen=True)
class TaskContext:
    task: TaskSemaforo
    key: dict
    query_params: dict
    registro_repo: RegistroRepository
-------cosa fa il processor-------
payload = TaskSemaforoPayload.from_json(msg)
task = payload.to_domain()

ctx = TaskContext(
    task,
    key=task.key,
    query_params=task.query_params,
    registro_repo=repo
)
----class QueryResolver--------
class QueryResolver:

    @staticmethod
    def resolve(template: str, ctx: TaskContext) -> str:
        values = {}
        values.update(ctx.key)
        values.update(ctx.query_params)
        values["id_semaforo"] = ctx.task.id

        query = template
        for k, v in values.items():
            query = query.replace(f"${{{k}}}", repr(v))

        return query
-----codice per sistemare la query di lettura-----
query = QueryResolver.resolve(self.query_template, ctx)

df = spark.read.jdbc(
    url=self.url,
    table=f"({query}) q",
    properties=self.props
)
--------RegistroUpdateStrategyFactory per settare le post action-----
class RegistroUpdateStrategyFactory:

    def create(self, tipo_caricamento: str) -> RegistroUpdateStrategy:
        if tipo_caricamento in ("CLIENTI", "RAPPORTI"):
            return IdAndDateUpdateStrategy()
        if tipo_caricamento in ("DATI", "DOMINI"):
            return OnlyIdUpdateStrategy()
        raise ValueError(tipo_caricamento)
------nella _get_common_data---------
strategy = RegistroUpdateStrategyFactory().create(task.tipo_caricamento)

post_actions = [
    UpdateRegistroAction(strategy)
]
-----------------------------------
from abc import ABC, abstractmethod
from pyspark.sql import DataFrame

class PostTaskAction(ABC):

    @abstractmethod
    def execute(self, df: DataFrame, ctx):
        pass

class UpdateRegistroAction(PostTaskAction):

    def __init__(self, strategy):
        self.strategy = strategy

    def execute(self, df, ctx):
        self.strategy.update(df, ctx)
-----------------------------------
class RegistroUpdateStrategy(ABC):

    @abstractmethod
    def update(self, df: DataFrame, ctx: TaskContext):
        pass


class IdAndDateUpdateStrategy(RegistroUpdateStrategy):

    def update(self, df: DataFrame, ctx: TaskContext):
        max_data = df.agg(
            F.max("data_va").alias("max_data")
        ).collect()[0]["max_data"]

        ctx.registro_repo.upsert(
            chiave=ctx.key,
            last_id=ctx.task.id,
            max_data_va=max_data
        )


class OnlyIdUpdateStrategy(RegistroUpdateStrategy):

    def update(self, df: DataFrame, ctx: TaskContext):
        ctx.registro_repo.upsert(
            chiave=ctx.key,
            last_id=ctx.task.id
        )

class DominiUpdateStrategy(RegistroUpdateStrategy):

    def update(self, df: DataFrame, ctx: TaskContext):
        ctx.registro_repo.upsert(
            chiave={"tabella": ctx.task.tabella},
            last_id=ctx.task.id
        )
-------------------------
class RegistroRepository:

    def upsert(
        self,
        *,
        chiave: dict,
        last_id: int,
        max_data_va: date | None = None
    ):
        sql = """
        INSERT INTO registro (chiave, last_id, max_data_va, updated_at)
        VALUES (:chiave, :last_id, :max_data_va, NOW())
        ON CONFLICT (chiave)
        DO UPDATE SET
            last_id = EXCLUDED.last_id,
            max_data_va = COALESCE(EXCLUDED.max_data_va, registro.max_data_va),
            updated_at = NOW()
        WHERE registro.last_id < EXCLUDED.last_id
        """
        self._execute(sql, {
            "chiave": json.dumps(chiave),
            "last_id": last_id,
            "max_data_va": max_data_va
        })


-----dopo la df.write----
for action in post_actions:
    action.execute(df, ctx)



