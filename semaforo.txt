1) task jdbc 2 jdbc (gruppo "SEMAFORO") per portarmi su postgres il semaforo sqlserver: "public.semaforo_mensile"
    Attenzione, la tabella deve andare in overwrite, non in append in modo che venga semppre sovrascritta

2) la vista che esegue il seguente sql:
---------------------------------------
select
sm.id id_sem,
sm.cod_abi as cod_abi,
sm.tabella as cod_tabella,
sm.provenienza as cod_provenienza,
sm.periodo_rif as num_periodo_rif,
sm.tipo_caricamento as cod_tipo_caricamento,
sm.colonna_valore as cod_colonna_valore,
sm.ambito as num_ambito,
coalesce(rm.max_datava, 20000101000000) as num_max_datava
from public.semaforo_mensile sm
left join public.registro_mensile rm
on sm.cod_abi = rm.cod_abi
and sm.tabella = rm.tabella
and sm.provenienza = rm.provenienza
where sm.id>coalesce(rm.id,0)
---------------------------------------
ritorna giá le righe che devono essere lette dall'orchestrator... conviene comunque fare una insert in overwrite
nella tab_tasks_semaforo ed utilizzare quella

Al momento del lancio, l'orchestrator inserisce in append nella registro le righe della vista? Non mi sembra la soluzione
migliore, perché se qualcosa va storto, quella riga rimane dentro nella registro.
Conviene che le righe nella registro vengano inserite/aggiornate (ognuna per la sua riga di competenza)
alla fine dell'orchestrator solo se tutto é andato bene... la max_datava va presa dalla tabella di
staging perché è dovrebbe essere più veloce (considerando che il target dovrebbe essere BigQuery).

Attenzione però: così facendo il confronto va fatto con la max dell'id su registro_mensile.
L'alternativa è fare update/insert per chiave nella registro_mensile; in questo modo la registro contiene sempre
l'id piú alto (per il confronto) e la data_va più alta.